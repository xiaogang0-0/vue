<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>es6相关</title>
</head>

<style>
  #box{
    width: 100px ;
    height: 100px;
    background: rgba(0,0,0,0.5);
    position: absolute;
   
    -webkit-transition: 1s ;
    -o-transition: 1s ;
    transition: 1s;

  }
  #box:hover{ transform:rotateZ(45deg) translateX(200px) scale(0.5)  ;}
  #box:hover{ transform:rotateZ(45deg) translateX(200px) scale(0.5)  ;}


</style>
<body>
 <!-- 阮一峰   学习网址：http://es6.ruanyifeng.com/#docs/intro  -->
 <!-- http://www.cnblogs.com/yang-11/p/6053556.html -->

<div id="box"></div>


<p>
  es6转码   Babel转码  
</p>
<p>
  Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。
  实例：
  <br>
  // 转码前
  input.map(item => item + 1);
<br>
  // 转码后
  input.map(function (item) {
    return item + 1;
  });
</p>

<br>let
<br>const 
<br>global对象


<br>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块{}内有效。


<br>1. let声明的变量只在它所在的代码块有效。
<br>2. for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
<br>3. 不存在变量提升(不存在预解析)
<br>4. 暂时性死区    简称 TDZ
<br>        +只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
<br>        +总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
<br>5. console.log(typeof undeclared_variable )
<br>
                + 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。
<br>
                +    var x = x;  // 不报错
                +    let x = x;   // 报错   也是因为暂时性死区：  使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。
<br>        + 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
<br> 6 一个代码块{}中  不允许重复声明



<br>  二、块级作用域<br>
<p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。

  <br>第一种场景，内层变量可能会覆盖外层变量</p>
  <p>第二种场景，用来计数的循环变量泄露为全局变量。(循环结束后i就变成全局的变量了)</p>

    1. 外层作用域无法读取内层作用域的变量 (同es5的 作用域 一样的道理)
    2. ()() =={}     匿名函数自执行 == 块纪作用域
    3. 

<p>三、块级作用域与函数函数声明</p>
</body>

<script type="text/javascript">
  
  {
      let a = 1;
      var b = 2;
  }
   // console.log(b)//2
   // console.log(a)//defined





for( let i = 0; i <10; i++ ){
// console.log(i) //0-9
}
// console.log(i)//defined





let a =[];
// var a =[];
 for(let i=0; i <10 ;i++){
    a[i]  = function(){
      console.log(i)
    }

 }
 // a[6]();// 6


//2. for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  // console.log(i);
// abc
// abc
// abc
}





//不存在变量提升
// console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
// console.log(bar); // 报错ReferenceError
let bar = 2;






//暂时性死区
//  - 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
var tmp= 123;


// if (true) {
//   // TDZ开始
//   tmp = 'abc'; // ReferenceError
//   console.log(tmp); // ReferenceError

//   let tmp; // TDZ结束
//   console.log(tmp); // undefined

//   tmp = 123;
//   console.log(tmp); // 123
// }





// console.log(typeof undeclared_variable )   //undefined    计算属性 没有定义  不报错  但是别存在暂存死区中
 // typeof x; // ReferenceError    暂存 死区
// let x;

// console.log(typeof undeclared_variable )
// 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。

// 有些“死区”比较隐蔽，不太容易发现。
function lll(x = y, y = 2) {
      return console.log([x, y]);
}

// lll(); // 报错  y not defined


function sss( y = 2, x = y) {
      return console.log([x, y]);
}
// sss();// [2,2] 


// 不报错
// var x = x;

// 报错
// let x = y;
// ReferenceError: x is not defined




// 6 一个代码块{}中  不允许重复声明








var tmp = new Date();

function f() {
  // console.log(tmp);//undefined   var 的预解析
  if (false) {
    var tmp = 'hello world';
  }
}

// f(); // undefined


// function f1() {
//   let n = 5;
//   if (true) {
//     let n = 10;
//       console.log(n); // 10
//   }
//   console.log(n); // 5
// }
// f1()


{{{{{
  let insane = 'Hello World';
  // console.log(insane)
}}}}};

//ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明
    if (true) {
      function f() {
        alert(0)
      }
    } //这是非法的

// ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
let rrrr = "123";
console.log(rrrr)









</script>
</html>
